// payments/internal/domain/event/v1/payment_events.proto
syntax = "proto3";

package domain.event.v1;

option go_package = "github.com/shortlink-org/billing/payments/internal/domain/event/v1;eventv1";

import "google/type/money.proto";

enum CancelReason {
  CANCEL_REASON_UNSPECIFIED = 0;
  CANCEL_REASON_USER        = 1;
  CANCEL_REASON_SYSTEM      = 2;
  CANCEL_REASON_AUTH_VOID   = 3;
  CANCEL_REASON_DUPLICATE   = 4;
}

enum FailureReason {
  FAILURE_REASON_UNSPECIFIED        = 0;
  FAILURE_REASON_DECLINED           = 1;
  FAILURE_REASON_INSUFFICIENT_FUNDS = 2;
  FAILURE_REASON_CARD_EXPIRED       = 3;
  FAILURE_REASON_INVALID_CVV        = 4;
  FAILURE_REASON_SCA_NOT_COMPLETED  = 5;
  FAILURE_REASON_FRAUD_SUSPECTED    = 6;
  FAILURE_REASON_NETWORK_ERROR      = 7;
  FAILURE_REASON_PROVIDER_ERROR     = 8;
}

// -----------------------------------------------------------------------------
// Minimal event metadata for idempotency and ordering.
// -----------------------------------------------------------------------------
message EventMeta {
  string event_id   = 1; // UUIDv7 — unique for each event
  string payment_id = 2; // Aggregate ID (payment UUID)
  uint64 version    = 3; // Aggregate version AFTER applying this event
  string invoice_id = 4;
}

// -----------------------------------------------------------------------------
// Business dimensions
// -----------------------------------------------------------------------------
enum PaymentKind {
  PAYMENT_KIND_UNSPECIFIED = 0;
  PAYMENT_KIND_ONE_TIME    = 1; // one-off purchase
  PAYMENT_KIND_SUBSCRIPTION= 2; // recurring charge
}

// Capture strategy (authorization vs immediate capture).
enum CaptureMode {
  CAPTURE_MODE_UNSPECIFIED = 0;
  CAPTURE_MODE_IMMEDIATE   = 1; // charge now (Created -> Paid)
  CAPTURE_MODE_MANUAL      = 2; // authorize now, capture later (hold)
}

// -----------------------------------------------------------------------------
// Domain events
// NOTE: We do not duplicate FSM state in the schema — the event type implies it.
// For clarity, each event below documents the resulting FSM state.
// -----------------------------------------------------------------------------

// State after applying: CREATED
// Initializes the payment aggregate with billing linkage and amount.
message PaymentCreated {
  EventMeta meta = 1;
  string invoice_id = 2;              // Reference to Billing
  google.type.Money amount = 3;       // Total amount to charge
  PaymentKind kind = 4;               // Business semantics
  CaptureMode capture_mode = 5;       // Capture strategy (immediate/manual)
}

// State after applying: WAITING_FOR_CONFIRMATION
// Customer action required (3DS/SCA). Optional step in the flow.
message PaymentWaitingForConfirmation {
  EventMeta meta = 1;
}

// State after applying: AUTHORIZED
// Authorization hold placed on the customer’s payment method.
message PaymentAuthorized {
  EventMeta meta = 1;
  google.type.Money authorized_amount = 2;
}

// State after applying: PAID
// Funds captured; payment completed.
message PaymentPaid {
  EventMeta meta = 1;
  google.type.Money captured_amount = 2;
}

// State after applying: REFUNDED
// Refund succeeded (partial or full). Entered on the first successful refund.
message PaymentRefunded {
  EventMeta meta = 1;
  google.type.Money refund_amount = 2;   // This refund operation
  google.type.Money total_refunded = 3;  // Cumulative after this operation
  bool full = 4;                         // total_refunded == captured
}

// State after applying: stays PAID (no state change)
// Refund attempt failed — the aggregate remains in PAID.
message PaymentRefundFailed {
  EventMeta meta = 1;
  FailureReason reason = 2;
}

// State after applying: CANCELED
// Payment canceled by user/system (includes void of authorization).
message PaymentCanceled {
  EventMeta meta = 1;
  CancelReason reason = 2;
}

// State after applying: FAILED
// Payment failed (declined, reverse, or authorization expired).
message PaymentFailed {
  EventMeta meta = 1;
  FailureReason reason = 2;
}
